### 规则

#### 元字符
- 字母和数字
- 符号（须转义）
- 匹配某种字符或字符集的符号
  + .  除换行与回车之外的任何符号
  + \n 换行
  + \r 回车
  + \s 空白
  + \S 非空白
  + ...
- 匹配某个位置的符号

#### 字符类 []
匹配集合中任一字符，可用 - 简写，可用 ^ 取反
例：[a-z]、[^0-9]
<br>
常用字符类被预设为特定元字符
- \w 字母和数字，即[a-zA-Z0-9]
- \W 非字母和数字，即[^a-zA-Z0-9]
- \d 数字，即[0-9]
- \D 非数字，即[^0-9]

#### 限定符
贪婪：匹配尽可能多的字符
-	{n} 匹配前一项 n 次
- {n, m} 匹配前一项不少于 n 次，不超过 m 次
-	{n，} 匹配前一项不少于 n 次
-	？匹配前一项 0 次或 1 次，表示可选
-	+ 匹配前一项至少 1 次
-	* 匹配前一项任意次数，包括 0 次

懒惰：匹配尽可能少的字符
- *? 重复任意次，但尽可能少重复
- +? 重复1次或更多次，但尽可能少重复
- ?? 重复0次或1次，但尽可能少重复
- {n, m}?	重复n到m次，但尽可能少重复
- {n, }? 重复n次以上，但尽可能少重复

#### 条件分支 |

#### 分组 ()
() 用于定义子模式，如 ([0-3]){3} 可匹配 000 ~ 333

#### 反向引用
子模式会记忆其匹配的文本，可以通过美元符 + 组号的方式引用
例：/(\d+)/.test('#333'); RegExp.$1 => 333

#### 后向引用
表达式中可通过组号引用子模式，用于匹配重复性文本。通过组号引用的是子模式匹配并记忆的文本，而不是子模式本身
<br>
例：\1表示＂此处的文本应该和组号为 1 的子表达式所匹配的文本一致＂
<br>
组号分配规则：
- \0 对应整个正则表达式
- 从左向右扫描两遍的：第一遍只给未命名组分配，第二遍只给命名组分配
- 可使用 (?:) 取消子表达式组号分配权

分组命名
<br>
- 命名：(?<name>)
- 引用命名分组：\k<name>

#### 零宽断言
<br>
零宽，表示字符串中不占位的位置，如字符串 'ab'，a 和 b 之间的那个位置
<br>
断言，即条件判断
<br>
零宽断言就是符合一定条件的位置

- (?=exp) 此位置后应该匹配 exp
- (?!exp) 此位置后不应该匹配 exp

以下两种 js 不支持
- (?<=exp) 此位置前应该匹配 exp
- (?<!exp) 此位置前不应该匹配 exp

常用零宽断言被预设为特定元字符
- ^ 此位置前不可存在任何符号
- $ 此位置后不可存在任何符号
- \b 单词边界
- \B 非单词边界

这些代表位置的元字符又被称为锚


#### 修饰 flag
JavaScript 支持三个 flag
- i：模式匹配不区分大小写
-	g：模式匹配是全局的，应该找出所有的匹配
-	m：在多行模式中执行匹配


### RegExp related API of String

- search(exp)
  + 参数：正则表达式
  + 返回：第一个匹配模式的子串的起始位置，如果没有匹配项，则返回 -1
  + 注意：只能匹配第一个，自动忽略 g 修饰符
- replace(target, replacement)
  + 参数：第一个是字符串或正则，第二参数为字符串或函数
  + 返回：替换后的新字符串，并不修改原字符串
  + 第二个字符串参数中可以用 $ 引用子模式
- match(exp)
  + 参数：正则表达式
	+ 返回：null 或数组
	+ 注意：全局模式下，返回所有匹配的文本构成的数组；非全局模式下，返回第一个匹配的文本和子模式匹配的文本构成的数组
- split(divider)
  + 参数：分隔符。可以是字符串，也可以是正则。
	+ 返回：切分后的数组。

### RegExp API

- exec(str)
  + 返回：null 或数组
  + 无论是否全局，均返回同样的数组，由第一个匹配的文本和子模式匹配的文本构成的数组
  + 当使用全局模式时，exec 会动态的设置 lastIndex，从而可以迭代的调用 exec 方法
- test(str)
  + 与 exec 方法等价

```js
var reg = /[a-z]/g;
var text = 'a1b2c3';
var result;
while ((result = reg.exec(text)) != null) {
  console.log(result[0]); // a, b, c
  console.log(result.index); // 0, 2, 4
  console.log(reg.lastIndex); // 1, 3, 5
}
console.log(reg.lastIndex); // 0
```



